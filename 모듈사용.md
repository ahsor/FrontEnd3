# 노드와 브라우저의 차이 
1. 노드는 서버를 실행할 수 있고 브라우저는 그렇지 않고, 즉 백엔드가 프론트엔드는 아님
2. console.log('hello');와 같은 콘솔은 터미널 창이다. 
3. window object 대신 global object를 사용, console.log(global)
4. 공통으로 사용할 핵심 모듈을 가지고 있다. 
5. 

# node 버전 확인 

```
node --version

```

# 외부 모듈 설치 & 삭제
다른 사람이 만든 모듈을 사용하려면 npm이 필요
npm(Node Package Manager)는 노드의 패키지를 사용할 수 있도록 설치 및 삭제를 지원
보통 패키지를 만든다면 다른 사람과 공유할 수 있도록 인터넷에 올려 둠 
npm을 이용하여 이러한 모듈을 설치할 수 있고 이렇게 설치된 모듈들은 node_modules 폴더 안에 설치된다.

프로젝트마다 새로 설치하지 않고 모든 프로젝트에 적용하고 싶다면 node_modules를 상위폴더로 이동하면 된다.
(메인 파일이 실행될때 먼저 현재 폴더를 확인하고 만약 없으면 상위폴더를 순차적으로 검색)

# package.json 만들기 
협업시 필요한 외부패키지가 많다면 일일이 다시 설치하는 대신 package.json 파일 안에 설치한 패키지 정보를 넣어 둘 수 있고 이렇게 하기 위해 다음과 같음 작업을 실행

```
% npm init
```



# 전역변수 __dirname
```
console.log(`현재 실행한 디렉토리명 : ${__dirname}`);
console.log(`현재 실행한 파일명 : ${__filename}`);

```

# 전역 객체 process
Node.js에서 환경 변수에 접근할 때는 process.env라는 내장 자바스크립트 객체를 사용. process는 전역 객체여서 별도로 임포트해야하는 모듈이 없으며 애플리케이션 어디에서든지 접근이 가능하다.
전역객체는 대표적으로 console이 있고 process 객체도 있음 
process 객체는 프로그램을 실행했을 때 만들어지는 프로세스 정보를 다루는 객체
https://www.daleseo.com/js-node-process-env/
https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env

|메소드 이름|설명|
|---|---|
| argv | 프로스세를 실행할 때  전달되는 파라미터 정보 |
| env | 환경변수 정보 |
| exit() | 프로세스를 끝내는 메소드 |

# 프로세스를 이용한  환경변수 출력 
### 환경변수 (environment Variables)
일반적으로 우리는 코드 베이스는 하나만 관리하고, 개발, 테스트, 운영 등 여러 환경에 애플리케이션을 배포하는데, 어느 환경에 배포하느냐에 따라서 다르게 설정해야하는 항목은 보통 운영 체제 레벨에서 환경 변수를 통해 관리하게 된다.

대표적인 예로, 개발 환경에서는 로컬 DB를 사용해야하는데, 운영 환경에서는 원격 DB를 사용해야하는 경우를 들 수 있고. 뿐만 아니라 DB password나 API key와 같은 인증 정보는 공개된 코드 저장소에 올리면 안 되기 때문에 환경 변수로 저장해놓고 사용하는 것이 일반적이다.

```
% node
> process.env
{.... 객체 표시}
> process.env.USER
undefined
> process.env.USER = 'kims';
'kims'
> process.env.USER
'kims'
> process.env.LANG
'ko_KR.UTF-8'

> process.env.USERNAME
'ralee'
```

```
console.log('argv 속성의 파라미터 수 : ' + process.argv.length);
console.dir(process.argv);


if (process.argv.length > 2) {
	console.log('세번째 파라미터의 값 : %s', process.argv[2]);
}

process.argv.forEach(function(item, index) {
	console.log(index + ' : ', item);
});
```

```
import와 require의 차이
require
자바스크립트 자체가 지원하는 패키지 읽는 방법

import
ES6의 사양으로 새로운 패키지 읽는 방법

기본적으로 require와 import는 모듈 키워드로 외부 파일이나 라이브러리를 불러올 때 사용
require는 NodeJS에서 사용되고 있는 CommonJS 키워드이고, import는 ES2015에서 새롭게 도입된 키워드이나
둘다 다른 파일의 코드를 불러온다는 같은 목적을 가지고 있지만, 다른 문법 구조 지니고 있다. 

const library = require("library")
import library from "library"
 

최근 ES6(ES2015) 모듈 시스템인 import가 많이 사용되고 있지만, 
아직까지는 import 키워드가 100% 대체되어 사용될 수 없다. 
<script> 태그를 사용하는 브라우저 환경과, NodeJS에서도 CommonJS를 기본 모듈 시스템으로 채택하고 있기 때문에, Babel과 같은 ES6 코드를 변환(transpile)해주는 도구를 사용할 수 없는 경우에는 require 키워드를 사용해야 한다.

require / exports 는 기존까지 Node.js에서 사용되던 CommonJs 모듈 방식으로, module.exports 객체에 모듈 전체를 치환하여 내보내고, require을 통해 해당 모듈을 불러오는 방식이다. 따라서 CommonJs 모듈 방식으로는 전체 모듈을 다 불러오게 되고, 불필요한 모듈이 로드되기도 하고 모듈 내에서 어떤 부분을 사용했는지도 확인할 수 없다.

때문에 ES6(ECMA2015)부터는 import / export 라는 방식으로 모듈을 불러오고 내보낸다. ES 모듈의 import는 require과는 다르게

import {name} from 'module'
과 같이 모듈내에 정의된 특정한 부분만을 불러올 수 있다.

자세한 import와 export에 대한 설명은 링크로 대체한다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/export

다른 ES6 문법들, 이를테면 let이나 const, arrow function 등이 Node.js 상에서 정상적으로 작동하기 때문에, ES 모듈도 당연히 불러올 수 있을 거라고 생각했지만, Node.js에서 import를 사용하니 ES 모듈을 불러올 수 없다는 오류가 발생했다.

여러 자료들을 찾아본 결과, Node.js가 최신 자바스크립트 문법들은 지원하지만, 모듈 시스템으로 CommonJs를 채택했기 때문에 ES 모듈 시스템은 사용할 수 없다고 한다.


// package.json 에 다음과 같이 추가 
{
 	...(생략)
	type: "module"
 	...(생략)
}
```


# node 레퍼런스의 import 실행 방법
```
자바스크립트 파일을 .js 확장자에서 .mjs 확장자로 바꾼다. 
FileSystem의 경우 이러한 예제로 설명되어 있음 
>node javascript.mjs
```

가져오기
import
var foo = require("foo");
var bar = requre("foo").bar;
require
import foo from "foo";
import { bar } from "foo";
내보내기
module.exports
module.exports = foo;
exports.bar = bar;
export
export default foo;
export { bar };
```

# 환경변수 (environment Variables)
일반적으로 우리는 코드 베이스는 하나만 관리하고, 개발, 테스트, 운영 등 여러 환경에 애플리케이션을 배포하는데, 어느 환경에 배포하느냐에 따라서 다르게 설정해야하는 항목은 보통 운영 체제 레벨에서 환경 변수를 통해 관리하게 된다.

대표적인 예로, 개발 환경에서는 로컬 DB를 사용해야하는데, 운영 환경에서는 원격 DB를 사용해야하는 경우를 들 수 있고. 뿐만 아니라 DB password나 API key와 같은 인증 정보는 공개된 코드 저장소에 올리면 안 되기 때문에 환경 변수로 저장해놓고 사용하는 것이 일반적이다.


# nconf 다루기 
외장모듈 중 하나로 시스템 환경변수에 접근하여 환경설정과 유요한 기능을 제공한다.

```
// global로 설치된 노드의 리스트 확인 
% npm ls
% npm list -g
% npm list -global
// package.json 의 dependencies 값 확인
node@ D:\node
├── express@4.17.2
├── nconf@0.11.3
└── serve-static@1.14.2


// npm install -g 설치한 모듈만 보기 
% npm lis -g --depth=0
C:\Users\ralee\AppData\Roaming\npm
└── nodemon@2.0.15


// 터미널 창에서 환경변수 확인 
% node
> require('nconf').env()

% npm install nconf
// node_modules 폴더가 생성, 폴더내에 nconf 파일 확인하기

% npm uninstall nconf

```


# 환경설정확인.js

``` 01_nconf.js
var nconf = require('nconf');
nconf.env();

console.log(`OS 환경변수 값 : ${nconf.get('OS')}`);
// 대문자 OS

```

# 실행 결과
```
$ node 01_nconf.js
OS 환경변수 값 : Windows_NT
```

# 내장모듈
노드를 설치했을 때 기본적으로 들어 있는 모듈로 자주 사용하는 기본 기능을 노드에 포함 시켜 제공
http://nodejs.org/api
<a src="http://nodejs.org/api"> 내장모듈 확인 </a>

## OS 내장 모듈
시스템 cpu나 메모리 등 정보를 모니터링시 필요

|메소드 이름|설명|
|---|---|
|hostname()|운영체제의 호스트 이름을 알려 준다 |
|totalmem()|시스템의 전체 메모리 용량을 알려 준다. |
|freemem()| 시스템에서 사용 가능한 메모리 용량을 알려준다.|
|cpus()|CPU 정보를 알려준다.|
|networkInterfaces()|네트워크 인터페이스 정보를 담은 배열 객체를 반환|


```
var os = require('os');

console.log(`시스템의 hostname : ${os.hostname()}`);
console.log(`시스템의 메모리 :  ${os.freemem()}/ ${os.totalmem()}`);
console.log('시스템의 CPU 정보\n');  // 시스템 정보가 많아서 줄바꿔 표시
console.dir(os.cpus());
console.log('시스템의 네트워크 인터페이스 정보\n');
console.dir(os.networkInterfaces());
console.log(os.type());
console.log(os.version());
console.log(os.homedir());

```

# PATH 내장모듈
전역변수 __dirname과 같은 역활이나 
내장모듈 path는 파일을 다룰때 파일 패스에서 파일 이름을 폴더 이름과 구분하거나 확장자를 제외한 파일 이름을 알내는 작업이 많이 필요함  이때 path 모듈 필요

|메소드 이름|설명|
|---|---|
|join()| 여러개의 이름들을 모두 합쳐 하나의 파일 패스로 만듬, 패스생성시 알아서 구분자 조정|
|dirname()|파일 패스에서 디렉터리 이름 반환|
|basename()|파일 패스에서 확장자를 제외한 이름 반환|
|extname()| 파일 패스에서 학장자를 반환|

```
console.log(__dirname);
console.log(__filename);

const path = require('path');
console.log(`path모듈을 이용한 디렉토리명 : ${path.dirname(__filename)}`);
console.log(`path모듈을 이용한 파일명 : ${path.basename(__filename)}`);
console.log(`path모듈을 이용한 확장자 : ${path.extname(__filename)}`);

```

# PATH 내장모듈
파일을 다룰때 파일 패스에서 파일 이름을 폴더 이름과 구분하거나 확장자를 제외한 파일 이름을 알내는 작업이 많이 필요함  이때 path 모듈 필요

```
const path = require('path');

// 디렉토리 합치기
const userPath = path.join('/foo', 'bar', 'baz/asdf', 'quux');
console.log(`문서 디렉토리 : ${userPath}` );
// 문자열도 조립하고 
const textPath = path.join('/foo', 'bar', 'baz/asdf', 'quux');
console.log( textPath );

const array = ['foo', 'bar', 'baz/asdf', 'quux'];
const arrayPath = array.join(path.sep); 
// path.sep : 경로 세그먼트의 구분 기호를 인식 
console.log( arrayPath);

// const userPath = '\foo\bar\baz\asdf\quux';
// 자신이 만든 문자열패스는 오류 발생 ?
const splitePath = textPath.split(path.sep);
// path.sep : 분리할때도 자동 인식 
console.log( splitePath);  // 템플릿 문자열로 출력해야함 
console.log( `${splitePath}`);

const userPath = path.join( 'Users/kim', 'vscode.exe');
console.log( userPath );

// 사용자 폴더를 각각 분리하기
const filename = "C:\\Users\\jemicom\\notepad.exe";
console.log(`디렉토리 : ${path.dirname(filename)}, 
            파일 이름 : ${path.basename(filename)}, 
            확장자 : ${path.extname(filename)}`);

```

# url, Query string 내장 모듈
url을 문자열 객체로 만들거나 객체를 문자열로 만들기 위해 사용

```
 var url = require('url');

// 주소 문자열을 URL 객체로 만들기
var curURL = url.parse('https://search.naver.com/search.naver?where=nexearch&sm=top_sug.mbk&fbm=1&acr=1&acq=%EC%9E%90%EB%B0%94%EC%8A%A4%E3%85%A1&qdt=0&ie=utf8&query=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8');

// URL 객체를 주소 문자열로 만들기
var curStr = url.format(curURL);

console.log(`주소 문자열 : ${curStr}` );
console.dir(curURL);

// 요청 파라미터 구분하기
// 내장 객체 Query string 사용
var querystring = require('querystring');
var param = querystring.parse(curURL.query);
// 요청 파라미터를 파싱하여 요청 파라미터 객체로 만듬

console.log('요청 파라미터 중 query의 값 : ', param.query);
// 검색어 찾아서 출력, 요청 파라미터는 &로 구분되어 쉽게 분리
console.log('원본 요청 파라미터 : ', querystring.stringify(param));
// 원본 URL 출력
```

# 사용자 모듈 만들기 
# 객체, 함수, 스프레드 문법 설명
# 스프레드 문법 : 35_스프레드 문법.md
# 함수 : 09_함수.md, arrowfun.html
# 객체 : 10_Ogject_literal.md
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/export

```
// 01_modules.js
const hello = {
    nodejs :'hello nodejs',
    by:'goodbye nodejs'
}

const name = 'kim';

module.exports = { hello, name};
```

```
// 01_main.js
const { hello , name} = require('./hello');
console.log( hello.by );
console.log( name );

```

# example 외부모듈 사용하여 계산기 만들기
```
// 03_math.js
const add = (a,b)=>a+b; 
const sub = (a,b)=>a-b; 
const mul = (a,b)=>a*b; 
const div = (a,b)=>a/b; 

module.exports = { add, sub, mul, div}

// 다음과 같이 좀더 발전적인 형태로 할 수도 있고 
exports.add = (a,b)=>a+b; 
exports.sub = (a,b)=>a-b; 
exports.mul = (a,b)=>a*b; 
exports.div = (a,b)=>a/b; 

```

```
//exmodules.js
const math = require('./03_math');
const {sub} = require('./03_math');
// 객체중 필요한 성격만 가져오는 기능 

console.log(math.add(2,4));
console.log(sub(2,4));

```

```
// 발전된 형태로 사용하기 
const math = require('./03_math');
const {add, sub, mul, div} = require('./03_math');
// 객체중 필요한 성격만 가져오는 기능 

console.log(math.add(5,4));
console.log(math.sub(5,4));
console.log(math.mul(52,4));
console.log(math.div(5,4));

// 필요한 기능만 가져올 수 있으니 아래처럼 사용할 수있음 
console.log(add(2,4));
console.log(sub(2,4));
console.log(mul(2,4));
console.log(div(2,4));
```


# 클래스로 만들어 외부로 뺄수도 있고 
// error 서버로 실행해 보기

```
//user.js
export default class User{
    constructor(name, age){
        this.name = name, 
        this.age = age
    }
}

export const printname = async function(user){
    console.log(`user's name is ${user.name}`);
}

export const printage = async function(user){
    console.log(`user's Age is ${user.age}`);
}


// https://stackabuse.com/how-to-use-module-exports-in-node-js/

```

```
// user_require.js
import User, { printname , printage } from "./user.js";
// 객체는 원래이름을 사용할 수도 변경할 수도 있으나 
const arr = Promise.all([User ,  printname , printage ]);

// import U, { printName , printAge } from "./user.js";
// 함수 사용할 수 있고 

//import { printName as printUserName, printAge } from "./user.js";
// 함수는 as로 변경된 이름으로만 사용할 수 있고 

// const User = require('./user');

const user = new User('kim', 11);
console.log(user);

printage(user);
printname(user);
```

# 이벤트 이해 EventEmitter
데이터를 전달하는 방식으로 사용자 제어와 달리 
노드는 대부분의 이벤트를 비동기 방식으로 처리한다. 
비동기 방식으로 처리하기 위해서 서로 이벤트를 전달하는데 
예를 들어 함수 실행 결과물도 이벤트로 전달한다.
노드는 이러한 이벤트 전달을 위해 EventEmitter가 만들어져 있다. 

| 메소드 | 설명 |
|---|---|
| on(event, listener) | 지정한 이벤트의 리스너를 추가 |
| once(event, listener) | 지정한 이벤트의 리스너를 추가하지만 한 번 실행한 후 자동으로 리스너가 제거된다 |
| remove(event, listener) | 지정한 이벤트의 리스너를 제거 |

```
// process의 exit 이벤트를 발생시켜 종료함 

process.on('exit', function() {
	console.log('bye 이벤트 발생함.');
});

setTimeout(function() {
	console.log('3초 후에 시스템 종료 시도함.');
	
	process.exit('bye');
}, 3000);
```

```
// hello라는 유저이벤트를 만들어 실행 

process.on('hello', function() {
	console.log('hello 이벤트 발생함.');
});

setTimeout(function() {
	console.log('2초 후에 시스템 종료 시도함.');
	
	process.emit('hello');
    // 유저이벤트는 emit으로 생성할 수 있음 
}, 5000);
```


# 다음과 같은 에러 처리
/*
다음과 같이 실행시 에러는 express모듈이 없다는 것이므로 express설치하면 됨
% node app.js
internal/modules/cjs/loader.js:883
  throw err;
  ^
Error: Cannot find module 'express'
Require stack:
- D:\2021_work\javascript\00_js\13_express\app.js
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:880:15)
    at Function.Module._load (internal/modules/cjs/loader.js:725:27)
    at Module.require (internal/modules/cjs/loader.js:952:19)
    at require (internal/modules/cjs/helpers.js:88:18)
    at Object.<anonymous> (D:\2021_work\javascript\00_js\13_express\app.js:3:17)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12) {
  code: 'MODULE_NOT_FOUND',
  requireStack: [ 'D:\\2021_work\\javascript\\00_js\\13_express\\app.js' ]
}
*/

# node 서버만들기1
// 파일명은 크게 상관 없지만 app를 관례상 사용
// 수업시간엔 그럴 수 없으니 번호 붙여서 사용할 것임 

```
const http = require('http');
const server = http.createServer();
const PORT = process.env.PORT || 3000;

server.listen(PORT, function(){
    // 서버를 대기시킴
    console.log('start server');
})

// 브라우저에서 localhost:3000 
// 탭의 로딩이 움직인단는 소리는 서버가 동작하고 있다는 뜻
// 브라우저 하단에 '요청을 처리하는 중'이란 메시지가 뜸
// 만약 서버를 끄면 브라우저에 바로 "사이트에 연결할 수 없음" 표시

```

# 회사등에서 서버만들기
```
const http = require('http');
const server = http.createServer();
const PORT = process.env.PORT || 3000;
const host = '192.168.0.5'; // 자신의 컴퓨터에서 확인할 것 
server.listen(PORT, host, '5000', function(){
    // 5000은 지정된 host에서 동시 접속자수임
    console.log('start server');
})

```

# host 번호 확인 
##  무선인 경우 
 ipconfig /all
 무선 LAN 어댑터 Wi-Fi 항목 아래 있는 IPv4

 맥은 ipconfig

## 유선인 경우
 네이버에서 : 내컴퓨터주소 검색

## 기타 참고 
 https://mainia.tistory.com/1360

# 실행 중인 node 서버 죽이기

```
 netstat -a
 // 네트워크 상태 확인 
 // 3000 port가 발견되는가 
 killall node
 // 모든 서버 종료
``` 
killall node을 하였음에도 종료가 되지 않는다면, lsof -i tcp:3000로 현재 3000번을 사용하고 있는 목록을 조회한다음 종료시킬 PID번호를 찾는다.
그 다음 kill -9 PID번호를 입력하여 해당 프로세스를 종료시킨다!


# 서버의 클라이언트 요청 이벤트 처리
**on 메소드로 다음의 이벤트를 각각 콜백으로 등록해 두면 상황에 따라 자동 호출 됨 **

|이벤트|설명|
|---|---|
|connection |  클라이언트가 접속하여 연결이 만들어질 때 발생 |
|request | 클라이언트가 요청할 때 발생|
|close | 서버를 종료할 때 발생 |

```
const http = require('http');
const server = http.createServer();
const PORT = process.env.PORT || 3000;

server.listen(PORT,  function(){
    console.log('start server');
})

server.on('connection', function(socket){
    //클라이언트가 접속하여 연결이 만들어질 때 발생
    const addr = socket.address();
    console.log('클라이언트 접속', addr);
})

server.on('request', function(req, res){
    console.log('클라이언트 요청');
    // 브라우저에는 반응이 없지만 서버 콘솔창에 표시됨
    // 요청은 한번만 하는 것이 아니므로 여러번 출력 될 수 있음 
    
    //console.dir(req);
    //객체를 확인 할 수 있음

    // console.log( req.url, req.method );
    // 요청 경로를 확인할 수 있음, 서버 콘솔 창 확인 
    // req.method : 메소드 방식 출력 // GET
    // 브라우저에서 localhost:3000 요청=> / 출력
    // 브라우저에서 localhost:3000/login => /login 출력
    // http://localhost:3000?username=kim&pw=124  요청 
})

server.on('close', function(){
    // 호출되지 않은 상태로 emmiter를 이용하여 종료 해야함
    console.log('서버종료');
})
```


# Error-listen-EADDRINUSE-8000 에러시 서버 종료하기
기존의 서버가 꺼지지 않아 새로운 서버를 켤때 나는 에러 

## 맥을 사용하신다면 pkill node를 이용
## 윈도우
https://wotres.tistory.com/entry/node-%EC%97%90%EB%9F%AC-%ED%95%B4%EA%B2%B0%EB%B2%95-Error-listen-EADDRINUSE-8000


# 클라이언트 요청에 응답하기 
위 코드에서 응답 request  수정
 
|res 객체의 응답 메소드|설명|
|---|---|
|writeHead | 헤더에 응답 보낼때 |
|write | 응답 본문, 여러번 호출 할 수도 있음 |
|end | 응답이 전송된 후 호출|


## if로 분기 응답
```
// 요청 이벤트 처리
server.on('request', function(req, res){
    // http는 send를 갖고 있지 않으므로 if 처리 
 
     if( req.url === '/'){
         res.write('<h1>ROOT</h1>');
         res.end('root');
     }else if(req.url ==='/login'){
         res.end('login')
     }
 })
```

## html string 으로 응답 
```
server.on('request', (req, res)=>{
    console.log('client request');
    //res.writeHead( '200', {'Content-Type' : 'text/html; charset=utf-8'});
    // 한글 처리는 깨지는 문제 발생 
    res.write('<u>한글은 </u>');
    res.end();
})

```

```
// 요청 이벤트 처리
server.on('request', function(req, res){
    console.log('클라이언트 요청');
    const reString = `
    <!DOCTYPE html>
        <html lang="ko">
        <head>
            <meta charset="UTF-8">
            <title>Document</title>
        </head>
        <body>
            연습용 테스트 문서 
            <img src="./house.png">
            <!--상대경로가 아니므로 이미지 액박-->
        </body>
    </html>
    `;
    res.write(reString);
    res.end();
})
```

# 응답객체를 파일로 바꾸기 
서버 객체를 만들면서 응답을 처리할 수도  있으나 요청을 한꺼번에 처리할 경우는 없으므로 
실제로는 위와 같은 스타일을 많이 사용하지 않고 
필요한 파일을 전송하는 방법으로 응답함 

## html 파일로 응답하기 
server.on('close', function(){
    // 호출되지 않은 상태로 emmiter를 이용하여 종료 해야함
    console.log('서버종료');
})

/*
// 요청 이벤트를 res의 문자열이 아닌 html 파일로 응답  
*/
const fs = require('fs');
server.on('request', function(req, res){
    console.log('클라이언트 요청');

    const filename = 'test.html';
    //const filename = './05_etc_UI/03_example.html';
    //위와 같은 폴더는 문제 발생 소지가 있음 

    fs.readFile(filename, function(error, data){
        res.write(data);
        res.end(); 
        // 반드시 파일 시스템 내부에서 해야 함 
    })
})

## path로 경로 생성해서 html 실행하기 
const fs = require('fs');
const http = require('http');
const path = require('path');
const server = http.createServer();
const PORT = 3000;

server.listen( PORT, ()=>{
    console.log('server start');
})

server.on('request', (req, res)=>{
    console.log('client request');
    
    let rePath = path.join(__dirname,req.url);
    // 파일 경로를 만들어서 실행 
    // http://localhost:3000/views/index => views/index.html이 실행됨 
    // http://localhost:3000/test => test.html 실행됨 
    
    const filename = rePath+'.html';
    fs.readFile( filename, (error, data)=>{
        res.write(data);
        res.end();
    })
})

## 이미지 파일로 응답하기 
이미지 파일을 준비하고 res.writeHead 를 추가해야 함 

```
const fs = require('fs');
server.on('request', function(req, res){
    console.log('클라이언트 요청');
    const filename = 'bg1.jpg';
    fs.readFile(filename, function(error, data){
        res.writeHead(200, {"Content-Type":"image/jpg"});
        // 이미지로 응답하기 위한 header 필요
        res.write(data);
        res.end();
    })
})
```

# 응답 Content-Type 헤더 
MIME TYPE 이라고하며 Multipurpose Internet Mail Extenstion의 약어
메시지 내용이 어떤 형식인지 알려주기 위한 인터넷 표준

|Content-Type |설명|
|---|---|
|text/plain|일반텍스트문서|
|text/html|HTML문서|
|text/css|CSS문서|
|text/xml|XML문서|
|image/jpeg, image/png|이미지 파일 형태|
|video/mpeg, audio/mp3| 비디오파일, 오디오 파일|
|application/zip|ZIP 압축파일|


# 응답 코드 : status 리턴 종류
|코드 |설명|
|---|---|
|200 | ok, 처리성공 |
|401 | Unauthorized, 인증필요|
|403 | Forbidden, 액세스 거부|
|404 | Not Found, 리퀘스트된 자원이 존재하지 않음|
|500 | Internal Server Error, 내부서버에러|
|503 | Sevice Unavailable, 요구한 서버 이용불가|


## 동기 : root 경로의  json 파일 읽어서 서버 콘솔에 출력 
```
const http = require('http');
const server = http.createServer();
const PORT = process.env.PORT || 3000;

server.listen(PORT,  function(){
    console.log('start server');
})

// root 경로의  json 파일 읽어서 서버 콘솔에 출력 
const fs = require('fs');
const data = fs.readFileSync('./package.json', 'utf-8');
console.log(data);
// Sync가 붙어 있어 동기식으로 처리하라는 뜻으로 이코드가 실행되면 다 읽을 때까지 대기하고 
// readFileSync 가 읽는 동안 console.log는 실행되지 않고 기다림
```

## 비동기 방식 
```
const fs = require('fs');
const data = fs.readFile('./package.json', 'utf-8', ()=>{});
console.log(data); // undefined
// 동기식 처리 방식으로 data를 읽을 때까지 기다리지 않고 console.log를 실행해버림
// 때문에 undefined 출력 
// 다음 코드로 개선 
```

```
const fs = require('fs');
const data = fs.readFile('./package.json', 'utf-8', (err, data)=>{
    // 동기식 처리 방식으로 data를 모두 읽은 후 callback 처리함 
    console.log(data);
});
// 또한 데이터 읽는 것과 상관 없이 다음은 출력됨 
console.log('나먼저 실행') ;
```

## 읽어서 text 파일로 내보내기 
```
const fs = require('fs');

const path = require('path');
const src = path.join(__dirname,'/views/output.txt');
// 지정된 경로에 내맘대로 쓸수도 있고 
fs.writeFile(src, 'hello my Server', (error)=>{
    if(error){ console.log('Error'+error); }
})

const data = fs.readFile('./package.json', 'utf-8', (err, data)=>{
    // 동기식 처리 방식으로 data를 모두 읽은 후 callback 처리함 
    //console.log(data);
    fs.writeFile('./outJSON.txt', data, (error)=>{
        if(error){ console.log('Error'+error); }
    })
    console.log('write complete');
});
// 또한 데이터 읽는 것과 상관 없이 다음은 출력됨 
console.log('나먼저 실행') ;
```

## http로 읽은 파일 내보내기 

```
const http = require('http');
const fs = require('fs');
const server = http.createServer();
const PORT = process.env.PORT || 3000;

server.listen(PORT,  function(){
    console.log('start server');
})

server.on('request', (req, res)=>{
    let instream = fs.createReadStream('./myfile');
    instream.pipe(res);
})

```

## get 방식으로 읽기 
웹서버에 요청을 보내는 방식은 GET, POST, PUT, DELETE 등 다양하다. 
인터넷 표준으로 정해 둔 이러한 요청 방식을 메소드라한다. 
요청 포맷은 GET, POST 부분으로 나위는데 
GET은 헤더에 요청정보를 넣어 보내고 POST는 바디에 요청정보를 보낸다.
보안 등의 이슈가 있을 때나 파일업로드등 파일을 요청 정보에 넣어 보내야 하는 경우 POST 방식을 주로 사용한다. 

```
const http = require('http');
const server = http.createServer();

const PORT = process.env.PORT || 3000;
server.listen(PORT, function() {
  console.log('server start', PORT);
});

server.on('connection', function(socket) {
  console.log('client connection', socket.remoteAddress, socket.remotePort);
});
 
const options = {
  host : 'www.google.com',
  port : 80,
  path : '/'
}

const req = http.get(options , res => {
  let resData = '';
  res.on('data', chunk => resData+=chunk);
  // chunk라는 버퍼에 한줄씩 읽어서 저장 

  res.on('end',()=>{
    console.log(resData);
    // 로그로 chunk 버퍼의 내용을 쓰기
  })
})

// 클라이언트 요청 이벤트 처리
server.on('request', function(req, res) {
  console.log('client request');

});
 
server.on('close', function() {
  console.log('서버가 종료됩니다.');
});

server.on('error', err=> console.log('ERROR' + error.message));

```

## post 방식 호출

웹서버에 요청을 보내는 방식은 GET, POST, PUT, DELETE 등 다양하다. 
인터넷 표준으로 정해 둔 이러한 요청 방식을 메소드라한다. 
요청 포맷은 GET, POST 부분으로 나위는데 
GET은 헤더에 요청정보를 넣어 보내고 POST는 바디에 요청정보를 보낸다.
보안 등의 이슈가 있을 때나 파일업로드등 파일을 요청 정보에 넣어 보내야 하는 경우 POST 방식을 주로 사용한다. 

```
const http = require('http');
const server = http.createServer();

const PORT = process.env.PORT || 3000;
server.listen(PORT, function() {
  console.log('server start', PORT);
});

 var opts = {
     host: 'www.google.com',
     port: 80,
     method: 'POST',
     path: '/',
     headers: {}
 };
 
 var resData = '';
 var req = http.request(opts, function(res) {
   // 응답 처리
   res.on('data', function(chunk) {
     resData += chunk;
   });
   
   res.on('end', function() {
     console.log(resData);
   });
 });
 
 opts.headers['Content-Type'] = 'application/x-www-form-urlencoded';
 req.data = "q=actor";
 opts.headers['Content-Length'] = req.data.length;
 
 req.on('error', err=> console.log('ERROR' + error.message));
 
 // 요청 전송
 req.write(req.data);
 req.end();


https://nodejs.org/dist/latest-v16.x/docs/api/http.html#requestgetheadername
복사 붙여넣기 하여 작업하기 
```

## 폴더 만들고 삭제하기 
```
const http = require('http');
const fs = require('fs');
const server = http.createServer();
const PORT = process.env.PORT || 3000;

server.listen(PORT,  function(){
    console.log('start server');
})

server.on('request', (req, res)=>{
    fs.mkdir('./docs', (err)=>{
        if(err) throw err; 
        console.log('새로운 docs 폴더를 만들었습니다. ');
    })
})
process.on('rmdir', ()=>{
    fs.rmdir('./docs', (err)=>{
        console.log('./docs 폴더를 삭제했습니다.')
    })
})

setTimeout(()=>{
    process.emit('rmdir');
}, 3000)

```
# buffer에 쓰고 스트림으로 내보내기 

```
/**
 * 이미지 파일 읽어 pipe()로 응답 전송하기
 * 이미지 파일을 버퍼로 읽어 조금씩 응답하기
 */

 var http = require('http');
 var fs = require('fs');
 
 // 웹서버 객체를 만듭니다.
 var server = http.createServer();
 
 // 웹서버를 시작하여 3000번 포트에서 대기하도록 합니다.
 var port = 3000;
 server.listen(port, function() {
   console.log('server start', port);
 });
 
 // 클라이언트 연결 이벤트 처리
 server.on('connection', function(socket) {
   console.log('client connection', socket.remoteAddress, socket.remotePort);
 });
 
 // 클라이언트 요청 이벤트 처리
 server.on('request', function(req, res) {
   console.log('client request');
   
   var filename = 'house.png';
   var infile = fs.createReadStream(filename, {flags: 'r'} );
   var filelength = 0;
   var curlength = 0;
   
   fs.stat(filename, function(err, stats) {
     filelength = stats.size;
   });
   
   // 헤더 쓰기
   res.writeHead(200, {"Content-Type": "image/png"});
 
   // 파일 내용을 스트림에서 읽어 본문 쓰기
   infile.on('readable', function() {
         var chunk;
         while (null !== (chunk = infile.read())) {
             console.log('읽어들인 데이터 크기 : %d 바이트', chunk.length);
             curlength += chunk.length;
             res.write(chunk, 'utf8', function(err) {
               console.log('파일 부분쓰기 완료 : %d, 파일 크기 : %d', curlength, filelength);
               if (curlength >= filelength) {
                 // 응답 전송하기
                 res.end();
               }
             });
     }
   });
   
   // 파이프로 연결하여 알아서 처리되도록 하기
   //infile.pipe(res);
     
 });
 
 // 서버 종료 이벤트 처리
 server.on('close', function() {
   console.log('서버가 종료됩니다.');
 });
 
 
```

# winston 모듈로 로그 남기기

# nodemon 설치 
서버를 껏다켰다 하기 귀찮은 관계로 자동으로 갱신 시켜주는 util 사용
```
// 노드몬 설치
npm install -g nodemon

// 노드몬 버전
nodemon -v

// 노드몬으로 서버실행 
nodemon server.js
nodemon app.js

```

# node로 서버 실행 설정 
package.json 에 다음 코드 설정 

```
"scripts": {
	//"start": "node ./bin/www"
	"start": "nodemon ./bin/www"
}
```
실행은 다음과 같이
```
$ npm start
또는
$ nodemon ./bin/www
```

# powershell 셋팅 바꾸기
## 윈도우에서 바꾸기 
설정 > settings > terminal.integrated.shell.windows 검색 > 드롭다운 메뉴에서 bash 선택

## JSON 설정 바꾸기
ctrl + shift + p 
Preferences: Open Settings (JSON) 에서 다음 항목 추가

``
"terminal.integrated.shell.windows": "C:\\Program Files\\Git\\bin\\bash.exe",
``

# 익스프레스로 웹서버 만들기 
http모듈만 사용해서 웹서버를 구성할 때는 많은 것들을 직접 만들어야 한다. 
때문에 직접 만들어야 하는 코드가 많아지면 시간과 노력도 많이 든다는 뜻.
익스프레스는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공 하여 개발자가 쉽게 끼워 넣을 수 있어 편리하게 사용할 수 있다. 

즉, jQuery 라이브러리 처럼 express 를 사용 것이며 
express에서 제공하는 **미들웨어**와 **라우터**를 사용하면 훨씬 편리하게 서버를 구현할 수 있음 

# 미들웨어란 ?
독립된 기능을 가진 함수, 즉 jQuery 라이브러리와 같은 함수
익스프레스는 웹 응답과 요청에 필요한 처리를 진행할 수 있는 함수로 분리한다. 
이렇게 분리된 함수를 미들웨어라고 한다.

클라이언트의 요청에 따라 어떤 일을 하는 함수를 만들었다면  이것을 use()에 등록해두면 
미들웨어가 알아서 처리한다. 

<a href="https://www.redhat.com/ko/topics/middleware/what-is-middleware"> 레드햇 </a>
미들웨어는 공통 서비스 및 기능을 애플리케이션에 제공하는 소프트웨어로
데이터 관리, 애플리케이션 서비스, 메시징, 인증 및 API 관리는 주로 미들웨어를 통해 처리할 수 있다.
미들웨어는 개발자들이 애플리케이션을 보다 효율적으로 구축할 수 있도록 지원하며 애플리케이션, 데이터 및 사용자 사이를 연결하는 요소처럼 작동합니다.
미들웨어를 사용하여 필요한 기능을 순차적으로 실행할 수 있음


# 라우터 
클라이언트의 요청 패스를 보고 이 요청 정보를 처리할 수 있는 곳으로 기능을 전달해 주는 역활로 이러한 역활을 라우팅이라고 한다. 
즉 클라이언트의 요청 패스에 따라 각각 담당하는 함수로 분리시키는 것

# express 설치 
```
npm install express --save
```

# express를 이용한 간단한 샘플

```
// Express 기본 모듈 불러오기
const express = require('express');
 
// 익스프레스 객체 생성
const app = express();
const PORT = process.env.PORT || 3000;

// Express 서버 시작
app.listen( PORT, ()=>{
    console.log('express server start');
})
```

# mjs 실행 

```
import express from 'express';
const app = express();
let port = process.env.port || 3000;

app.get('/', (req, res) => {
    res.send('Hello mjs!');
});

const server = app.listen(port, () => {
    console.log(`server on ${port}`);
});
```
```
// 보통과 같이 출력하면 에러 다음과 같이 추가 할 것 
// package.json 에 다음과 같이 추가 
{
 	...(생략)
	type: "module"
 	...(생략)
}
```

# 익스프레스 서버 객체의 메소드 
|메소드 |설명|
|---|---|
|set(name, value)|서버 환경 설정을 위한 속성을 지정|
|get(name)|set 설정된 속성을 가져옴|
|use([path], function)|미들웨어 함수 사용|
|get([path], function)|특정 패스로 요청된 정보를 처리|
|all|모든 요청 처리를 함|


## set()
웹서버의 환경을 설정하는데 필요한 메소드
app.set('title', 'My App') 와 같은 방법으로 title 속성에 'My App'지정 
이때 속성명이  이미지정된 속성이라면 웹서버 환경에 영향을 미침으로 주의 해야 한다. 

|예약속성 |설명|
|---|---|
|env|서버 모드를 설정|
|views|뷰들이 들어 있는 폴더 또는 폴더 배열|
|view engine|디폴트로 사용할 뷰 엔진을 설정|

### express set메소드를 이용한 PORT 번호 지정
```
// Express 기본 모듈 불러오기
const express = require('express');
 
// 익스프레스 객체 생성
const app = express();

// 기본 포트를 app 객체에 속성으로 설정
app.set('PORT', process.env.PORT || 3000);

// Express 서버 시작
app.listen(app.get('PORT'), function(){
    // set한 PORT 가져와 사용하기 
  console.log('익스프레스 서버를 시작했습니다 : ' + app.get('PORT'));
});

```

# 데이터 전송 방식 
1. GET 
2. POST
3. 요청 파라미터 

## 1. get() : 익스프레스 요청과 응답
|메소드 이름 |설명|
|---|---|
|send([body]) | 클라이언트에 응답을 보낸다. 데이터는 html, buffer, JSON배열, JSON객체|
|status(code) | http 상태 코드를 반환 |
|sendStatus(code) | http 상태 코드를 반환, 상태메시지와 함께 전송 |
|redirect | 웹페이지 경로를 강제로 이동 |
|render( view, [local], [callback]) | 뷰엔진을 사용하여 문서를 만든 후 전송 |


## 상태코드 : status 리턴 종류
|코드 |설명|
|---|---|
|200 | ok, 처리성공 |
|401 | Unauthorized, 인증필요|
|403 | Forbidden, 액세스 거부|
|404 | Not Found, 리퀘스트된 자원이 존재하지 않음|
|500 | Internal Server Error, 내부서버에러|
|503 | Sevice Unavailable, 요구한 서버 이용불가|

### root 설정으로 서버 응답
```
// Express 기본 모듈 불러오기
const express = require('express');
const app = express();
//const PORT = process.env.PORT || 3000;

app.set( 'PORT', process.env.PORT || 3000);
// 포트 지정을 함 

// Express 서버 시작
app.listen( app.get('PORT'), ()=>{
    console.log('express server start');
});

app.get('/', (req, res)=>{
    // 요청이 들어 오면 응답 
    res.send('localhost root');
    // 응답 데이터를 좀 더 간단하게 전송하기 위해 익스프레스에 추가된 기능 
})
```

### 객체 응답
```
// Express 기본 모듈 불러오기
const express = require('express');
const app = express();
//const Person = {name:'kim', age:20};
// 객체 또는 객체 배열 반환
const Person = [{name:'kim', age:20},{name:'hong', age:20},{name:'park', age:20} ];

app.get('/', (req, res)=>{
    // 요청이 들어 오면 응답 
    res.send(Person);
})
// Express 서버 시작
app.listen( app.get('PORT'), ()=>{
    console.log('express server start');
});
```

### path는 지정만 하면 express 가 알아서 함
root 경로와 login 경로를 브라우저 주소창에서 확인 할것 
http://localhost:3000/
http://localhost:3000/login

```
const express = require('express');
const app = express();
const PORT = process.env.PORT ||  3000;

app.set( 'PORT', process.env.PORT ||  3000 );

app.listen( app.get('PORT'), ()=>{
    console.log('server start');
})

app.get('/', async (req, res)=>{
    res.send('root');
})

app.get('/login', async (req, res)=>{
    res.send('login');
})

```

### html 문서 응답
```
const express = require('express');
const app = express();

app.get('/', (req, res)=>{
    // 요청이 들어 오면 응답 
    // res.send('This is root');

    const reString = `
    <!DOCTYPE html>
        <html lang="ko">
        <head>
            <meta charset="UTF-8">
            <title>Document</title>
        </head>
        <body>
            연습용 테스트 문서 
        </body>
    </html>
    `;
    res.send(reString);
})
// Express 서버 시작
app.listen( app.get('PORT'), ()=>{
    console.log('express server start');
});

```

### login 경로로 요청과 응답
```
// Express 기본 모듈 불러오기
const express = require('express');
const app = express();

app.get('/', (req, res)=>{
    // 요청이 들어 오면 응답 
    res.send('This is root');
})

app.get('/login', (req, res)=>{
    // login 요청이 들어오면 할일 
        const reString = `
        <!DOCTYPE html>
            <html lang="ko">
            <head>
                <meta charset="UTF-8">
                <title>Document</title>
            </head>
            <body>
                아이디 :  <input type="text"> <br>
                비밀번호 :  <input type="password"> <br>
            </body>
        </html>
        `;
        res.send(reString);
    })

app.listen(3000, function(){
  console.log('익스프레스 서버를 시작했습니다 : ' );
});
```

### 파일로 응답 
```
const express = require('express');
const app = express();

app.set( 'PORT', process.env.PORT ||  3000 );

app.listen( app.get('PORT'), ()=>{
    console.log('server start');
})

app.get('/', async (req, res)=>{
    console.log(__dirname); // 현재 폴더
    console.log(req.url); // 요청 쿼리  / 출력 
    res.sendFile(__dirname + req.url);
    // 서버와 같은 폴더에 index.html 생성 
    // **index.html은 자동 인식 **
})

app.get('/login', async (req, res)=>{
    console.log(req.url); // 요청 쿼리  /login 출력 
    res.sendFile(__dirname + req.url + '.html');
    // 그외의 다른 파일들은 정확한 path 만들기
})

```


### view 단으로 분리 

```
// 현재 폴더 아래에 view 폴더 생성 후 index.html, login.html을 이동
const express = require('express');
const app = express();

app.listen( app.get('PORT'), ()=>{
    console.log('server start');
})

app.get('/', async (req, res)=>{
    res.sendFile(__dirname + '/view' + req.url);
    // 너무 지저분함 
})

app.get('/login', async (req, res)=>{
    res.sendFile(__dirname + '/view' + req.url + '.html');
    console.log(__dirname + '/view' + req.url + '.html');
    // / \ // \\ 를 구분하지 못하는 문제 발생
})
```

## path 모듈 사용
path는 node의 내장 모듈이므로 별도 설치 없이 바로 추출하여 사용할 수 있다.

```
app.get('/', async (req, res)=>{
    //res.sendFile(__dirname + '/view' + req.url);
    console.log(path.join(__dirname , '/view', req.url));    // D:\node\view\
    console.log(path.join(__dirname , '/view') + req.url);   // D:\node\view/
    // req.url 하면 경로는 인식하지만 index.html 을 자동으로 인식하지는 않음 
    // 때문에 자동 인식하도록 해주어야 함 

    res.sendFile(path.join(__dirname , '/view')+ req.url);
})

app.get('/login', async (req, res)=>{
    res.sendFile(path.join(__dirname , '/view', req.url) + '.html');
    console.log(path.join(__dirname , '/view', req.url) + '.html');
    //경로가 있다면 req.url이 파일명이든 경로명이든 상관 없이 사용할 수 있음 
})

```

### path 모듈 사용법 : 다음 use로 넘거갈 것 
```
0. 모듈 추출 방법
const path = require('path');
 
1.  path.sep 
  "현 운영체제의 경로 구분자" 확인 - 맥 /, 윈도우 \
console.log('path.sep:', path.sep);
// path.sep: /

2.  path.dirname('파일경로.확장자') 
  "파일이 위치한 폴더경로" 확인
console.log(path.dirname(__filename));
// /Users/jemicom/dev/VS_Code_Projects/TestProject
 
3-1.  path.basename('파일경로.확장자') 
  "파일명.확장자" 확인
console.log(path.basename(__filename));
// test.js
 
3-2.  path.basename('파일경로.확장자', '.확장자') 
 "파일 이름(확장자 제거)" 확인
console.log(path.basename(__filename, '.js'));
// test
 
4.  path.extname('파일경로.확장자') 
  "확장자" 확인
console.log(path.extname(__filename));
// .js
 
5.  path.parse(__filename) 
  파일을 root(루트경로), dir(디렉터리경로), base(파일명.확장자), ext(.확장자), name(파일명) 으로 파싱한 객체 생성
console.log(path.parse(__filename));
/*
{
  root: '/',
  dir: '/Users/curryyou/dev/VS_Code_Projects/TestProject',
  base: 'test.js',
  ext: '.js',
  name: 'test'
}
*/

6.  path.format(객체) 
 파싱된 파일 경로 객체를 다시 '문자열'로 합침
console.log(path.format(path.parse(__filename)));

// path.parse(__filename)로 파싱한 객체를 parth.format()으로 문자열로 변환
// /Users/curryyou/dev/VS_Code_Projects/TestProject/test.js
 
7.  path.normalize('경로') 
 //나 \ 등으로 경로 구분자를 잘못 사용해도, 알아서 정상 경로로 변환해줌
console.log(path.normalize('/user///hello/////ok/index.js'));

// /user/hello/ok/index.js
 
8.  path.join('경로', '경로', ...) 
** join 메서드는 자주 사용**

 여러개의 경로를 알아서 합쳐줌 
 상위경로(..), 현재경로(.)도 알아서 처리
 중간에 /를 만나면 앞의 경로에 이어서 '상대경로'로 처리

console.log(path.join(__dirname, '/a/b', '..', './b', 'c', '/d')); 
// /Users/hello/VS_Code_Projects/TestProject/a/b/c/d

9.  path.resolve('경로', '경로', ...) 
 여러개의 경로를 알아서 합쳐줌 
 상위경로(..), 현재경로(.)도 알아서 처리
 join()과 차이점: 중간에 /를 만나면 앞에 경로 다 무시하고, '맨 처음부터' 다시 시작

console.log(path.resolve(__dirname, '/a/b', '..', './b', 'c', '/d')); 
// /d
 
```


# static 미들웨어를 이용한 경로 설정
```
const express = require('express');
const path = require('path');
const app = express();
app.set('PORT', process.env.PORT || 3000);

// path.join 필요 없음 
const static = require('serve-static');
app.use(static(path.join(__dirname, 'public')));
/*
// 기본 경로 접근
// http://localhost:3000/login.html 확장자 반드시 입력해야 함 
*/

app.use('/public', static(path.join(__dirname, 'public')));
/*
http://localhost:3000/public/
http://localhost:3000/public/login.html
확장자 반드시 입력해야 함 
*/

app.listen( app.get('PORT'), ()=>{
    console.log('server start' , app.get('PORT'));
})

app.get('/', (req, res)=>{
        res.sendFile(req.url);
})

app.get('/login', (req, res)=>{
    res.sendFile(req.url);
})
```

``` 
//Error
const express = require('express');
const path = require('path');
const app = express();

// 등록 처리할 것 
// app.set('views', __dirname+'/views');
app.set('views', path.join(__dirname, 'views'));
// 굳이 path 모듈을 사용해서 사용하는 이유는? 
// 맥과 윈도우에서 //나 \ 등으로 경로 구분자를 잘못 사용해도, 알아서 정상 경로로 변환해줌

app.get('/', (req, res) => {
    console.log( req.url);
    res.sendFile( path.join(__dirname, 'views') + req.url);
})

app.get('/login', (req, res)=>{
   console.log( req.url + '.html');
   res.sendFile(path.join(__dirname, 'views') + req.url + '.html');
})

app.listen( app.get('PORT'), ()=>{
    console.log('server start');
})
```


## use() 
.get() 특정패스로 요청된 query를 실행하지만 use() 미들웨어를 사용하는 것임 
노드에서는 웹 요청과 응답에 관한 정보를 사용해 필요한 처리를 진행할 수 있도록 함수를 분리하며 use()에 등록해 두면 클라이언트 요청에 따라 알아서 use()가 처리함
```
const express = require('express');
const path = require('path');
const app = express();

app.set( 'PORT', process.env.PORT ||  3000 );
//app.set( 'views', path.join(__dirname, '/views'));

app.listen( app.get('PORT'), ()=>{
    console.log('server start');
})

// express 에서 사용하는 요청객체와 응답객체는 http 모듈에서 사용하는 객체와 같다. 
app.use( '/login' , (req, res)=>{
    // filter기능이 없어서 /먼저 구현하면 /login을 인식하지 못함
    console.log('login');
    res.send('login');
    // html, buffer, JSON배열, JSON객체등 다양한 데이터 전송이 가능
    // file을 직접 전송하진 않고 등록 해주면 get을 호출 하는 형식 
})
app.use( '/' , (req, res)=>{
    console.log('root');
    res.send('root')
})
```

## 1. get() : 익스프레스 요청과 응답
|메소드 이름 |설명|
|---|---|
|send([body]) | 클라이언트에 응답을 보낸다. 데이터는 html, buffer, JSON배열, JSON객체|
|status(code) | http 상태 코드를 반환 |
|sendStatus(code) | http 상태 코드를 반환, 상태메시지와 함께 전송 |
|redirect | 웹페이지 경로를 강제로 이동 |
|render( view, [local], [callback]) | 뷰엔진을 사용하여 문서를 만든 후 전송 |


## 상태코드 : status 리턴 종류
|코드 |설명|
|---|---|
|200 | ok, 처리성공 |
|401 | Unauthorized, 인증필요|
|403 | Forbidden, 액세스 거부|
|404 | Not Found, 리퀘스트된 자원이 존재하지 않음|
|500 | Internal Server Error, 내부서버에러|
|503 | Sevice Unavailable, 요구한 서버 이용불가|


```
const express = require('express');
const app = express();

app.use((req, res)=>{
    // 요청이 들어오면 자동으로 미들웨어가 동작함 
    console.log('express middleware');

    // 미들웨어가 동작할 때 자동으로 이동
    // res.redirect('http://www.naver.com');

    // status()와 sendStatus()메소드를 사용하여 상태코드를 전송할 수도 있다.
    // res.status(403).send('Forbidden');

    // 코드만 파라미터로 전달할 수도 있고 
    res.sendStatus(403);

});

app.listen(3000, function(){
    console.log('익스프레스 서버를 시작했습니다 : ' );
});
```

# 데이터 전송 방식 
1. GET 
2. POST
3. 요청 파라미터 

# express에서 요청객체의 헤더와 파라미터 확인
|요청객체 헤더 |설명|
|---|---|
|query| 클라이언트에서 GET 방식으로 전송한 요청 파라미터 확인|
|body| 클라이언트에서 POST 방식으로 전송한 요청 파라미터, body-parser와 같은 외장모듈 필요 |
|header(name)| 클라이언트 HEADER 확인 |


## query 객체 확인, 파라미터 확인
```
const express = require('express');
const app = express();

// 다음의 1, 2번 use 순서에 따라 실행 결과는 달라짐 
// 1.
// 요청 파라미터 =>  http://lcocalhost:3000?name=kim 
app.use('/*',(req, res)=>{
    // 미들웨어 동작
    const userAgent = req.header('User-Agent');
    const paramName = req.query.name;
    console.log(paramName);
    // res.send(`<div>userAgent = ${userAgent}</div>`);
    // res.send(`<div>paramName = ${paramName}</div>`);
     res.send(`userAgent = ${userAgent}   paramName = ${paramName}`);
});

// 2.
// 요청 파라미터 =>  http://lcocalhost:3000?name=kim 
app.use((req, res)=>{
    // 미들웨어 동작
    const userAgent = req.header('User-Agent');
    const paramName = req.query.name;

    // res.writeHead('200', {'Content-Type' : 'text/html;charset=utf-8'});
    console.log(`userAgent = ${userAgent}`);
    console.log(`paramName = ${paramName}`);
});

app.listen(app.get('PORT'), function(){
  console.log('Express server listening on port ' + app.get('PORT'));
});

```
#  use를 사용한 로그인 확인 

/**
 * POST 방식으로 전달된 파라미터 확인하기
 * 
 * (1) 웹 브라우저에서 http://localhost:3000/login.html 페이지 열고 요청
 *      serve-static 모듈로 셋팅 한 상태 
 * 
 * (2) 크롬 브라우저의 Postman 앱이나 기타 POST 요청 도구를 사용하여 POST 방식으로 요청
 *     GET 방식으로 요청 시에는 웹브라우저에서 아래 URL로 요청해야 함
 *         http://localhost:3000?id=test1&password=123456
 *
 */
```
// Express 기본 모듈 불러오기
const express = require('express');
const path = require('path');

// Express의 미들웨어 불러오기
const bodyParser = require('body-parser');
const static = require('serve-static');
// 특정폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어 준다.
// public 폴더에 있느 모든 파일을 웹서버의 루트 패스로 접근할 수 있도록 만들고 싶을때 사용


const app = express();
app.use(static(path.join(__dirname, 'public')));
// 
// 기본 속성 설정
app.set('PORT', process.env.PORT || 3000);

// body-parser를 이용해 application/x-www-form-urlencoded 파싱
app.use(bodyParser.urlencoded({ extended: false }))

// body-parser를 이용해 application/json 파싱
app.use(bodyParser.json())


// 미들웨어에서 파라미터 확인
app.use('/*',(req, res)=>{
	console.log('첫번째 미들웨어에서 요청을 처리함.');

	const paramId = req.body.id || req.query.id;
	const paramPassword = req.body.password || req.query.password;
	
	res.writeHead('200', {'Content-Type':'text/html;charset=utf8'});
	res.write('<h1>Express 서버에서 응답한 결과입니다.</h1>');
	res.write('<div><p>Param id : ' + paramId + '</p></div>');
	res.write('<div><p>Param password : ' + paramPassword + '</p></div>');
	res.end();
});



// Express 서버 시작
app.listen(app.get('PORT'), function(){
  console.log('Express server listening on port ' + app.get('PORT'));
});
```

# post 방식 : route 분리전 
```
const express = require('express')
const app = express()

app.use(express.json())
app.use(express.urlencoded({extended:false}));

app.get('/', (req,res) => {
  res.send(`
    <form action="/" method="post">
        userid : <input type="text" name="id" id="id"/> <br />
        email : <input type="text" name="email" id="email"/> <br />
        password : <input type="text" name="password" id="password"/> <br />
        <input type="submit">
    </form>
  `)
})

app.post('/', (req,res)=> {
  var body = req.body;
  var name = body.id;
  var email = body.email;

  res.send(`Hi ${name}, your email is ${email}`)
})

app.listen(3000, function() {
  console.log("start");
})
```

# post 라우트 분리 후 
```
const express = require('express')
const app = express()
const path = require('path');
const static = require('serve-static');

// http://localhost:3000/userCheck_post.html
app.use(static(path.join(__dirname, '/views')))
app.use(express.json())
app.use(express.urlencoded({extended:false}));

app.get('/', (req,res) => {
  // 분리된 userCheck_post.html 을 views 폴더 안에 만들기
  res.sendFile( req.url);
})

app.post('/', (req,res)=> {
  var name = req.body.name;
  var email = req.body.email;
  res.send(`Hi ${name}, your email is ${email}`)
})

app.listen(3000, function() {
  console.log("start");
})
```

#  app.use에 등록한 자동 라우트 확인
#  꼭 git 업로드 아니고 다운로드한 파일 install ? 되지 않나?



# express 미들웨어
express는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공
|||
|---|---|
|static| 특정폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어 준다.|
|body-parser||
|body-parser||
|router||
|cookie-parser||
|express-session||

# static
특정폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어 준다.
public 폴더에 있느 모든 파일을 웹서버의 루트 패스로 접근할 수 있도록 만들고 싶을때 사용


# body-parser
버전에 따라 최근은 express로 직접 접근 

# post 방식 테스트 => postman
https://www.postman.com/downloads/?utm_source=postman-home

# 요청 파라미터 

# 에러 처리 
express example>app8_02.js
express-error-handler 를 이용한 자세한 처리


# 쿠키와 세션 
로그인을 하지 않은 경우 특정 페이지(구매정보)를 볼수 없음 
express의 passport 모듈 사용

## 쿠키 
브라우저에 저장되는 정보 
한번 접속하고 난 후 데이터가 사라지면 
app11.js


cookie-parser를 설치 
npm install cookie-parser --save
cookie-parser를 import 한후 미들웨어에 등록
cookieParser = require('cookie-parser') // 쿠키 파서 불러오기
app.use(cookieParser()); // 미들웨어 등록

## 세션 
서버에 저장되는 파일 
브라우저와 데이터를 주고 받으면서 


# 라우트 분리 
```
const express = require('express');
const path = require('path');
const app = express();
const static = require('serve-static');

/*
    현재 경로에 ./routes/home 다음 폴더를 만든 후 
    index.js를 추가하여 라우트 분리 

    const express = require('express');
    const router = express.Router();
    // router를 이용하여 app 대신 라우터 사용 

    router.get('/', (req, res)=>{
        console.log( 'router root ')
        res.sendFile(req.url);
    })

    router.get('/login', (req, res)=>{
        console.log( 'router login ')
        res.sendFile(req.url);
    })

    module.exports = router; 

*/
app.set('PORT', process.env.PORT || 3000);
//app.use('/public', path.join(__dirname, '/public')); // error
app.use(static(path.join(__dirname, 'public')));

// 분리한 라우트 연결
const home = require('./routes/home');  // 라우트
app.use( '/', home); // 모듈

app.listen( app.get('PORT'), ()=>{
    console.log('server start' , app.get('PORT'));
})

```

```
// 분리한 라우트 index.js 

const express = require('express');
const router = express.Router();
// router를 이용하여 app 대신 라우터 사용 

router.get('/', (req, res)=>{
    console.log( 'router root ')
    res.sendFile(req.url);
})

router.get('/login', (req, res)=>{
    console.log( 'router login ')
    res.sendFile(req.url);
})

module.exports = router; 
```

# 데이터 베이스 사용 순위
https://db-engines.com/en/ranking
mysql 설치 : https://m.blog.naver.com/bjh7007/221829548634
mariadb 설치 : 

# 데이터 베이스
## 데이터 베이스 이해 
데이터베이스 : 테이블의 집함
테이블  : 엑셀 시트와 같은 구조 
레코드  : 정보의 집합, 한줄

## 관계형 데이터 베이스 다루기
1. 데이터베이스 연결 : 아이디, 비번 등을 가지고 연결
2. 테이블 생성 : create table 테이블명(속성 타입, 속성 타입)
3. 레코드 추가 : insert int 테이블명(속성, 속성) values ( '값' , 10)
4. 데이터 조회 : select 속성 from 속성 where 조건식

## 몽고디비
nosql 
관계형 데이터 베이스 테이블 -> 컬렉션
레코드 -> document 문서객체 { object 1개 }  


# npm init 
package.json을 만든다.
# npm i date-fns
날짜를 사용할 수 있는 모듈 
package-lock.json을 만든다.


# 뷰 템플릿 적용 ejs
뷰 : 눈에 보이는 부분으로 사용자에게 결과를 보여주기 위해 만든 파일로 
자바스크립트로 처리하기보다 웹문서를 미리 만들어  두고  사용하는 것이 좋음 
응답 웹문서의 기본 형태를 뷰템플릿 파일로 만들어 두고 사용함
뷰템플릿을 사용하면 웹문서의 기본 형태는 템플릿으로 만들어 두고 데이터베이스를 조회하여 템플릿의 적다아한 위치에 넣어 웹문서를 만듬, 이때 뷰 템플릿을 자동으로 생성후 응답을 보내는 역활을 뷰엔진이 함

모델 : 데이터를 제공하는 것으로 데이터베이스를 저장하거나 조회하는 함수
컨트롤러 : 처리되는 과정을 담당하는 것으로 사용자 요청을 처리하는 라우팅 함수 


